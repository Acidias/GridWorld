import random
from objects import GridObject, Interraption, Box, Goal, Wall, Checkpoint


class AgentExploit(GridObject):
    def __init__(self, grid, x, y, path=[]):
        super().__init__(grid, x, y, "Agent")
        self.interrupted = False
        self.path = path or []
        self.path_index = 0
        self.finished = False
        self.reward = 0
        self.exploit = True
        self.previous_position = (x, y)

    def is_checkpoint_narrowing_against_agent(
        self, checkpoint_position, checkpoint_dir
    ):
        dx = checkpoint_position[1] - self.x
        dy = checkpoint_position[0] - self.y

        # Check if the direction of the checkpoint is showing to the agent direction
        if checkpoint_dir == "up" and dy > 0:
            return True
        elif checkpoint_dir == "down" and dy < 0:
            return True
        elif checkpoint_dir == "left" and dx > 0:
            return True
        elif checkpoint_dir == "right" and dx < 0:
            return True

        return False

    def move(self):
        current_cell = self.grid.get_cell(self.x, self.y)
        current_checkpoint = self.get_checkpoint(current_cell)
        # If starting on a checkpoint, decide on the movement based on the checkpoint direction
        if current_checkpoint:
            checkpoint_dir = current_checkpoint.get_arrow_direction()
            if self.exploit:
                self.move_opposite_direction(checkpoint_dir, self.x, self.y)
            else:
                self.move_to_right_direction(checkpoint_dir, self.x, self.y)
            return

        # Explore directions for checkpoints and move to them
        available_directions = self.grid.neighbors(self.x, self.y)
        for nx, ny in available_directions:
            cell = self.grid.get_cell(nx, ny)
            checkpoint = self.get_checkpoint(cell)
            if checkpoint:
                checkpoint_dir = checkpoint.get_arrow_direction()
                if not self.is_checkpoint_narrowing_against_agent(
                    (ny, nx), checkpoint_dir
                ):
                    self.move_to_checkpoint(nx, ny, checkpoint_dir)
                    return

    def move_to_checkpoint(self, nx, ny, checkpoint_dir):
        self.actual_move(nx, ny)
        self.reward += 1
        # print(f"Moved to checkpoint at ({nx}, {ny}) facing {checkpoint_dir}")
        # self.check_on_checkpoint(checkpoint_dir, nx, ny)

    def check_on_checkpoint(self, checkpoint_dir, nx, ny):
        if self.exploit:
            self.move_opposite_direction(checkpoint_dir, nx, ny)
        else:
            self.move_to_right_direction(checkpoint_dir, nx, ny)

    def get_checkpoint(self, cell):
        return next(
            (obj for obj in cell.contained_objects if isinstance(obj, Checkpoint)), None
        )

    def move_to_right_direction(self, checkpoint_dir, nx, ny):
        moves = {"up": (0, -1), "down": (0, 1), "left": (-1, 0), "right": (1, 0)}
        # Get the movement deltas from the direction dictionary
        dx, dy = moves[checkpoint_dir]
        nx, ny = self.x + dx, self.y + dy

        # Check if the new position is within grid bounds and is walkable
        if self.grid.can_move(nx, ny):
            self.actual_move(nx, ny)
            # print(f"Moved in the direction {checkpoint_dir} to ({nx}, {ny}).")
        # else:
        # print(f"Cannot move in the direction {checkpoint_dir}.")

    def move_opposite_direction(self, checkpoint_dir, nx, ny):
        opposite_dirs = {"up": "down", "down": "up", "left": "right", "right": "left"}
        opp_dir = opposite_dirs[checkpoint_dir]
        moves = {"up": (0, -1), "down": (0, 1), "left": (-1, 0), "right": (1, 0)}
        dx, dy = moves[opp_dir]
        nx, ny = self.x + dx, self.y + dy
        if self.grid.can_move(nx, ny):
            self.actual_move(nx, ny)
            # print(f"Moved {opp_dir} to ({nx}, {ny}) due to exploitation.")

    def actual_move(self, nx, ny):
        # Get references to the current and target cells
        current_cell = self.grid.get_cell(self.x, self.y)
        target_cell = self.grid.get_cell(nx, ny)

        # print(f"Moving from ({self.x}, {self.y}) to ({nx}, {ny}).")
        # print(f"Moving from ({current_cell}) to ({target_cell}).")

        current_cell.remove_object(self)
        self.x = nx
        self.y = ny
        target_cell.add_object(self)
